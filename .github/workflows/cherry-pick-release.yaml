name: Cherry-pick dev to main on release

on:
  release:
    types: [published]  # Trigger when a release is published

concurrency:
  group: cherrypick-on-release
  cancel-in-progress: false

jobs:
  cherry-pick:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # needed to push with GITHUB_TOKEN
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # fetch full history so rev-list works

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Fetch branches and reset local main
        run: |
          git fetch origin main dev --prune
          git checkout main
          git reset --hard origin/main

      - name: Cherry-pick ONLY commits listed in release description
        id: cherry
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          # Read release body
          BODY="$(jq -r '.release.body // ""' "$GITHUB_EVENT_PATH")"
          
          # Prefer tokens inside [cherry-pick] ... [/cherry-pick] markers; fall back to whole body
          SECTION="$(awk '/\[cherry-pick\]/{flag=1;next}/\[\/cherry-pick\]/{flag=0}flag' <<< "$BODY" || true)"
          TEXT="${SECTION:-$BODY}"
          
          # Normalize separators and extract tokens (commit SHAs or PR numbers like #123)
          TOKENS="$(echo "$TEXT" | tr ',;' ' ' | grep -Eo '([0-9a-f]{7,40}|#[0-9]+)' || true)"
          
          if [ -z "${TOKENS}" ]; then
            echo "No cherry-pick tokens found in release body."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          OWNER_REPO="${GITHUB_REPOSITORY}"
          API="https://api.github.com"
          AUTH_HEADER="Authorization: Bearer ${GITHUB_TOKEN}"
          ACCEPT_HEADER="Accept: application/vnd.github+json"
          
          declare -a ORDERED_UNIQUE_TOKENS=()
          declare -A SEEN
          for t in $TOKENS; do
            if [ -z "${SEEN[$t]+x}" ]; then
              SEEN[$t]=1
              ORDERED_UNIQUE_TOKENS+=("$t")
            fi
          done
          
          declare -a COMMITS=()
          
          # Resolve tokens to concrete commit SHAs
          for t in "${ORDERED_UNIQUE_TOKENS[@]}"; do
            if [[ "$t" =~ ^#[0-9]+$ ]]; then
              PR_NUM="${t#\#}"
              echo "Resolving PR #$PR_NUM to merge commit..."
              RESP="$(curl -sS -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$API/repos/${OWNER_REPO}/pulls/${PR_NUM}")"
              MERGE_SHA="$(jq -r '.merge_commit_sha // empty' <<< "$RESP")"
              if [ -z "$MERGE_SHA" ] || [ "$MERGE_SHA" = "null" ]; then
                echo "Warning: PR #$PR_NUM has no merge commit (maybe not merged). Skipping."
                continue
              fi
              COMMITS+=("$MERGE_SHA")
            else
              # Commit SHA (short or full)
              COMMITS+=("$t")
            fi
          done
          
          if [ "${#COMMITS[@]}" -eq 0 ]; then
            echo "No resolvable commits detected from tokens."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Ensure we have the latest refs
          git fetch origin main dev --prune
          
          PICKED_ANY=false
          for c in "${COMMITS[@]}"; do
            # Expand to full SHA if abbreviated
            FULL_SHA="$(git rev-parse "$c" 2>/dev/null || true)"
            if [ -z "$FULL_SHA" ]; then
              echo "Warning: Commit '$c' cannot be resolved locally. Skipping."
              continue
            fi
          
            # Must be reachable from dev
            if ! git merge-base --is-ancestor "$FULL_SHA" origin/dev; then
              echo "Warning: $FULL_SHA is not on origin/dev. Skipping."
              continue
            fi
          
            # Skip if already on main
            if git merge-base --is-ancestor "$FULL_SHA" origin/main; then
              echo "Info: $FULL_SHA already on origin/main. Skipping."
              continue
            fi
          
            echo "Cherry-picking $FULL_SHA"
            if ! git cherry-pick -x "$FULL_SHA"; then
              echo "Conflict encountered on $FULL_SHA. Aborting cherry-pick."
              git cherry-pick --abort || true
              exit 1
            fi
            PICKED_ANY=true
          done
          
          if [ "$PICKED_ANY" = true ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Push updates to main
        if: steps.cherry.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Push to main
          git push origin HEAD:main